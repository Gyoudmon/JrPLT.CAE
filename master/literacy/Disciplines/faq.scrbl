#lang scribble/manual

@(require "../literacy.rkt")

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-root-story{常见疑问}

本章所涉及的问题都比较常见和典型，
相信有此疑问的人一定已经自己做过很多功课。
但我还是想强调一句，编程对学生和家长来说都是比较新颖的技能，
零基础的这两个群体其实没有太大差别。
因此，请家长保持谦逊，花点耐心来认真思考我的回答。

@handbook-scenario{如何选择程序语言？}

@tag:TLDR

这个问题本身不应该不存，因为很少有人会只用一种程序语言。

@tag:deep

计算机系本科必修语言包括 C++ 和 Java；
有追求的学生(比如想当黑客了)还应该会 C、Lisp、Python 等诸多不同风格的语言；
特别的，想做数学研究的学生还会接触更多普通人闻所未闻的语言。

本科毕业之后大致有两条线，研究生深造(含硕士和博士)和软件行业就职。
这时候你大概率没得选，导师、领导会直接指定你用什么语言。
所以，@racketresultfont{不用奇怪，会多门程序语言既非困难、更非了不得的事。}

@handbook-action[#:tag "how_to_first"]{如何选择第一门程序语言？}

@tag:TLDR

如果只是在少儿编程市场里选，学生其实压根没得选，
只有 C++ 和 Python 两个选项。
因此，长话短说，Python 适合想快速上手的学生；
C++ 适合想在专业性上走得远的学生。
特别是，如果你的目标是信息学奥赛，那只能选 C++。

@tag:deep

当谈到“学编程”的时候，至少要考虑两个目的：
学会这个系列的课程/技能；将它用作谋生的工具。
这两个目标内在联系紧密，外在差异也可能很明显。
比如，你在学校时按部就班学了 C++ 和 Java，
找工作时却发现 PHP/Python 的职位最多
(这就是个例子，不要深究是不是真的这两个职位最多。
因为这显然要考虑地区和时期)。

也就是说，“学程序语言”和“用程序语言”是两件事。
这个事实决定了你在网上搜索“学编程”的信息时要特别留意作者的出发点。
实际上，正是因为大多数关于编程的建议都是针对找工作的(也即“用语言”这个目标)，
尤其是针对那些基础没打好、但觉得做软件来钱快的初学者。
适用于他们的建议几乎肯定不适用本文读者，
因为你们的孩子有足够充分的时间来打基础，
@racketoutput{合理规划、步步为营}，等到他们开始找工作时，
虽仍然还有各种困惑，但“用什么语言”一定不在其列。
他们有能力现学新语言。

具体来说，“先 Python 后 C++”花费的总时间
肯定多于“先 C++ 后 Python”。
因为，有 C++ 的基础，Python 可以不用学而直接使用。
反过来却不行。
这有点像，你考了手动挡驾驶证可以直接开自动挡的车；
但考过自动挡驾驶证还得额外训练手动挡，
虽然难度肯定比完全的新手低。
是的，现在确实很少人学手动挡了。
同理，只学 Python 或许也够用了。

那么，入门时同时学 C++ 和 Python 行不行呢？
行，但是不建议。因为中学正好也是孩子学业压力最重的时期，
同时学两门语言花费的总时间很可能更多。
如果条件允许，可以给孩子找个伴，
一人选一门语言，学内容相似的课程(这个很关键)，
课后多交流对比两门语言的差异。

最后，所有想帮助孩子规划编程学习路线的家长，这有两条建议：

@itemlist[
 @item{如果你能找到靠谱的老师，请主动持续跟老师交流，
  一段时间之后你或许能得到相对合理的建议，甚至能得到市场营销以外的路线。
  言下之意，你得认识自己和你的孩子，并且要让老师知道你们的想法和习惯，
  不要自己瞎猜。

  @racketoutput{在子女教育方面，请家长务必保持谦逊。}
  而且，人际关系是个复杂议题，“成年人的江湖经验”既是优势也是劣势。}
  
 @item{如果你找不到靠谱的老师(这才是正常现象)，那没有捷径，只能自己去学。
  我是说，你自己真的去学习编程，亲手敲代码，而不是“看”网上别人的观点，看不明白的。
  这么做的好处是，你可以跟孩子一起学，你自己本专业的知识或许就是孩子的“他山之石”；
  万一你学成了，你也多了一条收入途径。好多软件工程师的妻子就是这么入坑的。}]

@handbook-action[#:tag "cpp_vs_python"]{C++ 和 Python 的异同}

C++ 和 Python 都是程序语言，这是废话。
不废话的是，学计算机和编程并不是用语言来分界的，
这跟你选外语语种相当不同。

以下结论适用于所有程序语言(大概率也适用于母语和外语)：
@racketoutput{假设存在一门包罗万象的语言，
 那么所有具体的语言都只是这门语言的一个子集。
 于是，学编程的真正含义就是在学这个无所不包的程序语言，
 用它跟计算机交流，指导计算机完成你要求的任务。
 从某种意义上说，数学最接近这么一门包罗万象的语言。}
具体到 C++ 和 Python，它们都能达到与计算机交流的目的，
但是能力有差别，性能(办事效率)有差别，软件生态有差别，
因而入门难度、擅长领域、技能贬值速率也都有差别。

@handbook-event{语法}

语法比较尴尬，它既重要也不重要，主要是大多数人对它的理解都不在点上。

从功能和实用性角度来讲，语法方面的差异最不值一提，
用熟了都会内化成习惯。
就像日本人从来不嫌弃自己的母语有多笨拙。

但既然是语言，就不能只看功能需要，
还应该考虑可读性和精确性。
总体上说，Python 和 C++ 的语法在这两方面都不错。
Python 语法的简洁性比 C++ 更高，
但也更死板，甚至到了干扰你编码的程度，
是为矫枉过正。

因为语法直接跟人的偏好和品味有关，
不可能讨论出共识，因此不再继续展开。

@handbook-event{编译执行和解释执行}

这是应用程序的两种基本运行方式，
存在这两种运行方式的最直接的考量是
开发效率和运行效率的权衡。

如果将运行程序比作参加考试，
那么 Python 就是普通学生，
他们会规规矩矩地读题、思考、答题。
这是解释执行。
C++ 是学霸……吗？不是，
C++ 是擅长作弊的学生，
他们考试之前先做一遍背下答案，
拿到试卷之后不看题目、
照着空格直接填答案。
这是编译执行。
所以 C++ 程序跑得比 Python 程序快很多。

不过，Python 程序也可以先编译再运行。
因此，编译执行和解释执行并不是 C++ 快、Python 慢的唯一原因。
但是其他原因就不适合在这里解释了。
如果你对此感兴趣，那你应该先学 C++。

@handbook-event{REPL}

REPL 是 Read-Evaluate-Print-Loop 的首字母缩写。
即，读(表达式)-计算(表达式)-打印(结果)的循环。
它跟操作系统提供的 shell 是同一种东西。

Python 这样的解释执行语言都从 Lisp 那继承了这个循环，
有了这个东西，在学习阶段可以快速探索某个陌生的语法或语句的功能；
在实际项目中，可以方便地执行单个函数并检查结果是否符合预期。

C++ 这样的编译执行语言没有上述便利。
不过可以通过其他手段来弥补，
比如成熟的测试方案。
再不济勤写碎片程序多点击“编译运行”按钮。

总之，REPL 代表的是一种眼界、一种方法论。
要充分发挥其优势，需要长期经验积累，
并从系统工程设计角度与它配合好。
否则就会变成摆设。

@handbook-event{内存管理与垃圾回收}

现在普通人能接触的计算机都遵循着那个叫做冯诺伊曼的人提出的“存储程序”思想。
也即，所有程序运行时，都要想办法把自己的代码和数据加载到内存中。

继续以考试作为类比，Python 考生这回开了外挂了，
他们用的草稿纸比较智能，答案誊到试卷中之后，
用过的草稿纸就自动整备好供你继续打草稿。
C++ 考生可就憋屈了，他们必须自己规划好
草稿区域，免得不同题目的草稿互相干扰。

内存管理是个相当复杂的主题，
除了上面比喻涉及的垃圾回收机制，
还有指针、引用等学 C++ 会碰到的难点概念。
这些大学生学都费劲。

这也是为什么我建议“先学 C++ 再学 Python”，
Python 并非没有这些东西，它们只是以另外的形式存在而已，
有时候并不能完全绕开，
这时没有C++基础就会很难理解。

@handbook-event{静态类型与动态类型}

数据类型是所有编程初学者都应该重点关注的概念，
因为@emph{类型决定人和机器如何解读数据}。
比如数字@racket[16]是当作年龄处理还是当作学号处理
(后者不应该参与算术运算)。

C++ 是静态类型语言，要求所有的变量都必须先声明类型；
Python 是动态类型语言，没有这个要求，因为在它看来所有的数据都是“东西”。

乍一看，你会觉得 Python 挺好，在减少初学者的学习负担。
实际上，动态类型正是导致 Python 性能低的另一个关键原因，
因为它每次操作数据时都要先问一遍“你的类型符合我的需要吗？”。
关键是，即使 Python 不要求你这么做，
你自己的脑子里也得时时刻刻有这个意识。
否则，过段时间你肯定看不懂自己在写啥
(别人就更看不懂了)。

我推崇入门时选静态类型语言，
不只是养成个好的习惯问题。
@racketresultfont{用类型思考问题是初学者的必修课}，
也是软件能正常且正确运行的第一道保障。

顺带说一句，
C++ 的静态类型也只是比 Python 的强那么一丢丢，
用来入门培养类型思维是足够了。
将来你或许有机会研究更纯粹的类型论(这已经是一个趋势了)，
然后回过头来才能真正理解我这个观点的用心良苦。

其实，Python 也能声明类型，只是摆设意义更大一些，但也聊胜于无。
如果你学 Python，最好用起来，不要嫌麻烦。

@handbook-event{模块化}

模块化是学习编程过程中较早接触的概念，
用于将较大项目的海量代码合理存储到不同文件里，
以方便分工和合作。

Python 和其他大部分语言一样，
一个文件就是一个模块。
这也符合初学者的直觉：
写出一个函数的签名之后，
立即开始写函数的功能算法。

C++ 从 C 那继承了“头文件”这样一种繁琐的机制。
一个文件仍然是一个模块，
但是这个模块里面的函数需要单独提出来，
放到另一个文件里(那就是“头文件”)。

大部分情况下手写头文件是真的在增加工作量。
不过，在极少数场景，
它相当于提供了一个“开箱即用”的功能清单,
否则你肯定需要花更多时间来写说明书。
这是后话，不展开了。

学习阶段保持原滋原味，
将来做正经软件项目时，
C++ 的这个糟粕设计也是可以用其他方法弥补的。

@handbook-event{其他}

Python 还有两个优势， 一是入门年龄可以更小一些；
二是配置学习环境(安装必要的软件)要容易很多。
这些都是新手友好的标志。

不过这两个优势都算不上硬核，
本来最适合入门编程的年龄应该不低于12岁，
入门太早心智发育、考试科目的知识积累都不够，
算不上有多划算。

总之，关键是要老师靠谱(有系统和成熟的学科视野、最好有大型项目经历等)。
C++ 和 Python 的(其他)差异对于青少年来说没有那么大。
否则，先学哪个语言都是在浪费时间，不如把精力放在数理化上。

最后，计算机科学并不是数学的子集，
也并不是数理化学好了就能自动学会计算机。
我们一样有很多基础问题要独立研究。
比如， 如何设计一个支持量纲分析的类型系统。
物理学得好，但是没有程序语言理论的视野，
压根不会发现这里暗藏的问题，
但是很可能会发牢骚，“写单位换算代码太特么麻烦了”。
(这个问题，微软的F#语言已经有了一个聊胜于无的尝试)。

@handbook-scenario{没有兴趣能不能学编程？}

@tag:TLDR

能。而且应该学。
实际上，零基础的人(无论是否成年)都不能准确判断自是否对此感兴趣。

@tag:deep

与编程有关的活动，大致可以分为两大类：

@itemlist[
 @item{商业行为。主要指的就是各行各业根据行业需要划分出的作为软件从业者干的活，
  会有人为代码和软件支付报酬。}
 @item{非商业行为。这里不会有人专门给你的代码支付报酬，
  但这些代码的价值会以其他形式体现。具体可以细分为很多小类：

  @itemlist[
 @item{自娱自乐，或出于兴趣；或想通过写程序来提高工作效率、给生活以便利，
    或者干脆就是闲得无聊打发时间(就像，有人练书法、有人学乐器、有人研究宠物料理)；}
 @item{学术研究，计算机科学领域的自不必说、学科交叉研究也略去不表。
    其他硕士、博士，以及科学家的本职工作中有越来越多的部分离不开计算机的辅助，
    没人愿意一直把精力浪费在可以编程解决的脏活上；}
 @item{安全攻防，即把代码当作某种攻击或防御的武器，比如保护自己的隐私。
    这里不详细展开。}]}]

人生中的所有重大抉择，最终都可以归结为“认识自己”，
剩下的交给运气。这条原则对初学者尤其有效。于是，
说完了懂编程可以干什么，再来谈谈学编程的人。

人这一辈子都在做着各种各样的事，大多数事情都谈不上专业，
但没人会仅仅因为做不了职业选手就不去做，
这最典型的例子是厨艺、各类健身运动。

学编程的人可以按以下几个维度分类：

@itemlist[
 @item{内驱型。就是没来由的喜欢，这也是最好理解的一种。
  这类未必能达到所有类型中的最高成就，
  但却是最有可能发明新技术、引领领域走向的一种。}

 @item{社交型。比如，为了在朋友中显得与众不同；班里的学霸、
  喜欢的异性朋友很擅长这个；极端一点的，单纯想帮朋友解决难题。
  这种情形也未必没有好的结果，有人因为女朋友QQ被盗而破解了QQ密码系统。}

 @item{创客型。比如，已经有了别的兴趣，尤其是那些科技创造类的兴趣，
  希望通过编程来让自己的本职兴趣锦上添花。
  开源界因为这个原因而反过来贡献优秀软件的例子数不胜数。}
 
 @item{竞技型。这是大多数非专业的家长对孩子的期望，
  编程类白名单赛事越来越多。虽然好处很直接，
  但家长们往往低估了这条路的风险。
  就以含金量最高的信息学奥赛来说吧，
  它的本质就是@bold{针对中学生}的选拔性考试(要不冠名“奥林匹克”呢)，
  要想走通这条路，学生大概率要停掉考试科目来专门训练。
  这也就是它尴尬的地方，数学、物理、化学、生物奥赛，
  即使失败了，还可以惠及该科目的高考。
  信息学奥赛失败了，那也就同时浪费了本该用来准备高考的时间
  (数学和计算机科学的关系我后面会详细说)。}

 @item{思维型。学习这个领域的思维方式，所谓“他山之石，可以攻玉”。
  这也是最值得鼓励的一种类型。实际上，发达国家之所以大力推广
  以 STEM 为代表的针对中小学生的科创类课程，这才是根本目的。
  社会需要分工，不需要人人都是全才，个人也应该能自主选择，
  但总有一些共同的基础技能是时代发展的必须。
  60年前或许只要会认字、能看报纸就行，现在就必须要会使用智能设备。
  十年后又会是什么样，谁都不好说……吗？}
 
 @item{谋生型。懂编程来钱快，这不丢脸。
  但是成年人恐怕没时间学思维，或者学了老板也不买账(高端公司才重思维)。
  这也是学编程要趁早规划的现实考量。}]

以上几个维度不会单独存在，同一个人往往会同时属于好几个维度，
差别在于各个维度的比例不同。由此也可以看到，
@racketerror{单论“是否感兴趣”不足以评判别人想学编程的意愿。
 而且，让课程变得有趣，能尽可能多的照顾不同需求、不同层次的学生，
 是老师的责任。}

这的关键论点在哪呢？编程和计算机科学是工科学科，
但它与其他理工科的显著不同是@racketresultfont{它完全没有实体。
 因此，不可能让一个零基础的人准确判断自己是否对此感兴趣。}
比如，假如在传统抓阄活动中加入手机、键盘和显示器，
幼儿抓到了它们，能说明这孩子是对编程感兴趣吗？
显然不能，手机和显示器只能代表“会发光的盒子”，
替换成电视机甚至烟花都差不多；键盘是可以按的积木，
孩子或许会觉得这就是个减压玩具。
再比如，我们已经接触到了一些孩子，
他们声称自己极度抗拒信息类课程，
然后转身就沉浸在魔方、汉诺塔这类实体益智玩具中无法自拔，
而完全不知道这类玩具的玩法正是经典计算思维(算法学习过程中
大概率会碰到的经典例题)。
唯一准确判断孩子是否感兴趣的方法只有“真的去学”，
而且老师的眼界和教学的实施过程很重要，
否则极易消耗孩子的耐心。
学编程对预备技能(鼠标键盘的基本操作、
英文词汇量)有一定要求而导致孩子很难在初期就体验到学习的快乐。

对中小学生而言，家长在决定是否让孩子学编程的时候，动机可以不那么功利。
因为无论家长怎么想，孩子学成能够收获的好处都绝对远超预期。
@racketoutput{没有相关“收获体验”的家长，
 很难真的看懂网络上的“学编程有什么好处”。
 家长可以跟孩子一起学。}

@handbook-scenario{学编程能提高学习成绩吗？}

@tag:TLDR

从培养学科素养的角度看肯定能；
但是否能提高眼前的考试分数，影响因素就很多了。
比如老师能否激发学生的整体学习激情、
学生是否能够领悟到跨学科学习的奥义，
等等。

比如，我知道的我自己的学生里就有好几个，
虽然只上过我的某些分科课程，
但他们会因此而对“学习”本身产生兴趣，
继而带动其他课程的成绩一起提高
(动手型课程都有这个优势)。

@tag:deep

跨学科学习是时代和现代教育的发展趋势，
但是真正有效的学科交叉往往都是指大学课程，
特别是研究生课程(硕士和博士都是研究生)，
参与交叉的学科各自都有过硬的基础积累。

在中小学阶段，跨学科教学往往指的是“综合性课程”。
小学、初中、高中这三个阶段，综合性课程的比重
依次递减，高中阶段的重心会以传统的分科课程的
组合为主，因为高中是学生开始积累专业深度的起点。

举例来说，中学理科主要分为物理、化学、生物三门主课。
你可能已经知道，2017年开始，小学突然冒出来一门叫做“科学”的课程。
大多数家长都会想当然的认为，这不就是以前的“自然”课嘛，
而且反正初中要学，小学科学真的很鸡肋啊。

科学和理科的关键区别在于，科学是@bold{综合课程}，
强调的是不同学科之间的联系和统一，
@racketresultfont{用于扩展知识体系的广度}；
其他理科都是@bold{分科课程}，保持各学科的边界，
@racketresultfont{讲究扩展知识体系的深度}。
这个关系已经很明显了，在“吸收前人知识”这个阶段，
它们不能互相替代。

从授课方式来讲，
分科课程以知识理解为主，对老师有较强的依赖(虽然不只是刷题这一种方式，
但苦于被关键考试压着，大多数老师和学生都在无脑刷题这条不归路上蛮干)。
综合课程则强调学生为本，有探究式、项目式等多种有别于分科课程的教学方式。
@racketoutput{不过，授课方法不是好的分类维度，优秀的老师不挑方法}。
而且，对于初中生，理论是上可以把学理化生的时间都划给科学的，
只是现实中目前还没有学校敢这么做(合格的科学老师太少了，
也没有适合科学课的考试设置)，将来有没有就不好说了。

于是，你知道综合课程和分科课程有联系也有不同，
关键不总是能互相替代，
我们就有了继续讨论的基础。

下面分别说明编程和其他学科的交叉关系。

@handbook-action{编程与@type{计算机科学与工程}和@type{信息技术}}

是的，它们仨代表的不是同一个东西，但是一般人也不需要分得太清楚。

简单来说，计算机科学与工程是大学的一级学科，下面有诸多细分专业，
是正儿八经地学习计算机系统的方方面面。
各专业对编程能力的要求并不相同。

信息技术是中小学的一门课程。
这门课教你如何使用电脑(和常用软件)、知道智能设备在生活中的应用、
普及非专业人士应该知道的信息学知识。
其中包括计算思维和Python(以前是 Visual Basic)。
在信息技术课上，编程能力占比不高。

学编程与你是否想做计算机科学家或专业软件工程师没有必然联系，
它只是时代发展的一种基础技能，甚至是生存技能(不仅仅是找工作)。
实际上，现在 Python 之所以会大行其道，
就是因为它提供给你一个@racketresultfont{即使不走专业路线也能轻松编程}的选项。
发达国家大肆宣扬的所谓“人人能写码”的口号，
其实就是以 Python 作者为代表的一些人的理念。

到这里，重新思考 C++ 和 Python 的区别，
以及如何在它们之间做选择。
可以不必非得从技术角度考虑，
就看 Python 的定位和你对自己的认识，
思路也能清晰很多。

道理我都懂，可你是不是跑题了？
我们不是在说提高成绩的事吗？
信息技术又不是主课，提这个干嘛？
@racketoutput{优秀的学生要学会提正确的问题}。
否则你成绩越好，就越像文盲成年人口中的“读书读傻了的书呆子”。

@racketerror{信息技术课虽然不算在中考和高考的总分里,但它仍然是必修课}。
能考上大学的人不多,选计算机专业的就更少了。
什么都等大学时再学，你们真的可能错过一辈子。
家长可以问问自己为什么不会编程？
不过，一件宝贝，你拥有它你能知道它有多好，
但从来没有拥有过，那你自然也不知道自己缺失了什么。

说正经的，五大奥赛，只有信息学奥赛没有对应的高考科目。
这个现象说明了什么呢？最起码，信息学有它存在的价值。
那么问题就应该转化为“为什么重要场合都见不到它”。
因为，教育改革需要时间，说不定我们正处在这个过程中呢。
关键障碍在哪里呢？不妨假设，如果高考考信息学会怎么样？
学校需要配备足够的机房，选择这门课的学生应当人手一台电脑(平板不行)。
这些都是钱啊。现在开的起像样的信息学课程的学校都不多，
还有很多学生买不起电脑呢。高考考信息学对他们就很不公平了，
只能以独立于高考的形式在小范围里筛选。

如果你的学校恰好重视信息学教育，那你是幸运儿，
已经领先很多人了。有这资源不好好利用，
反倒在那想“在别的学校都是副科，就你把自己当个宝”。
那我只能说，“你回去吧，我教不了”。

@handbook-action{编程与@type{语文}和@type{英语}}

语文代表母语语言类课程；
英语代表第一外语类课程；
编程代表的是计算机语言类课程。
以上三句话里出现了三个“语言”，
毋庸置疑前两个“语言”说的是同一个东西，
第三个“语言”跟它们也一样吗？
从神经科学和脑科学的角度来看，
它们都是“语言学造物”，
会激活相同的脑区，
也都会以某种方式影响人的思维，
因此它们差别确实不大。
在美国某些洲，
程序语言与小语种外语具有同等的毕业凭证效力。

程序语言只关乎“阅读”和“写作”，
而不考虑“口语”和“听力”。
这点很有意思，第一次听到这个说法你估计会一愣，
然后猛然间惊觉确实是这么回事。
你可以试试对着同行朗读代码，看对方抽不抽你。

程序语言中会出现大量英语单词，
究其本质都只是一些符号，
因此发明程序语言的人自然更乐意选用自己已经熟悉的单词。

由此可见，学习编程至少能增加英语词汇量。
在编程过程中，你需要不断给各种概念(变量、函数等等)命名，
这是天然练习“遣词造句”能力的机会。

相对于其他专业的学生，计科院的学生不太依赖笔记类软件，
因为代码和文档比任何笔记都更便利。
而初学者多的是“将所学知识点以注释的形式写在代码里”的机会，
这也是天然的说明文或散文写作练习。

此外，对中小学生来说，输入英文要比输入中文容易得多；
大量有价值的编程资料都是英文写的，而且措辞往往通俗易懂。
学生自然是多了一条“认真学英语”的理由和途径。
都不用英语老师苦口婆心“为什么学好英语很重要”。

以上都是直接、具体的好处。
还有一些隐藏的额外好处就不展开了。

我好像没有提语文？
这可是母语能力啊，上面提及的遣词造句和写作，
以及对程序逻辑的理解和交流，
哪一样不都得先经由母语加工才行？

顺带一提，初学者多半会有疑问，为什么不直接用中文/英文来编程？
因为有歧义、写起来也啰嗦（你想想解数学题时把所有公式都用大白话写出来有多闹心）。
因此，@racketerror{不要建议学生“将来你可以发明个语言来用中文编程”}。
这是相当外行的思路，只会被行家当笑话看。
自娱自乐可以，比如你欣赏文言文的精练之美，
想发明个语言像文言文写作一样的写算法，没问题。
但不要期望能靠它推动世界发展或赚钱。

再顺带一提，软件工程领域确实有那么一小撮人坚信存在某种方法可以将人类语言逐步精化，
并最终翻译成可靠的计算机代码，
现在 ChatGPT 已经初步证实了他们的想法。
但需要注意的是，
这种跟“发明中文编程语言”并不是一回事，
因为 ChatGPT 生成的代码终究也是要落实到某个具体的程序语言上的。

@handbook-action{编程与@type{数学}和@type{科学}}

要把这三者的关系讲清楚了，确实很不容易，我尽量用通俗易懂的话来表达。

如果你看书仔细，你会发现好多理工科的教科书都会强调自己所研究的学问
“在现实生活中无处不在”。但当学生真的好奇请教时，经验少的任课老师却
未必说得清楚这些知识到底体现在哪。好尴尬。

也就是说，过去的理科在分科教学时很不接地气。
开明的老师发现了这个问题，他们中的不少人就开始尝试各种方法来让自己的学科变得接地气
(比如写科普课外读物、研发各类实体/数字教具、增加课程中的活动或实验)。
到了现在，出现了以STEM为代表的各类综合课程。
其中最值得一提的是，“计算思维”成为了最核心的素养之一。

那先来谈谈什么是计算思维。最初它指的是“像计算机科学家一样思考和解决问题”，
但它的实际应用远不止计算机科学这一个领域，而是真的“无处不在”。概括来说
就是这四种能力：问题分解、模式识别、模式抽象、算法设计。比如：

@itemlist[
 @item{问题分解：将复杂的应用题分解成一系列单个步骤，然后按步骤拿分。
  不会分解问题，你就拿不到步骤分、结果错就全错了，多可惜啊。
  结果对也很可能是蒙对的，换一道题多半就不对了。}
 @item{模式识别：通俗的说就是找规律。昆虫是虫子的一种，
  它们一定有头、胸、腹三部分，也一定有且只有六条腿。
  蚂蚁是昆虫、蝴蝶是昆虫；但是蜘蛛不是昆虫，因为它有八条腿。}
 @item{模式抽象：几何中的对称图形是对物理平面镜成像的抽象；
  食物网是对自然界中生物捕食关系的抽象；
  计算机科学中的网状结构又是对食物网、人际网、互联网等各种网的抽象。}
 @item{算法设计：通俗的说就是“(探索)解题步骤”。因式分解；
  配平化学方程式；绘制受力分析图等等。}]

以上四种技能，最难理解的是“模式抽象”，但它也是学理工科一定绕不过去的砍。
文科生通常不服气，为啥总有人觉得“学理科就显得很灵光、学文科就显得傻傻的”。
关键差别就在于对抽象能力的要求不同，数学和计算机科学对抽象能力的要求最高。
文科当然也是有的，比如 政治老师会强调，这个世界上没有“公司”这个东西，
只有一个个具体的“xxx公司”。公司就是对各种具体企业的抽象。
理科生从小接受抽象训练，没处可躲；文科生之所以选文科，
大概就是因为没碰到好老师，导致自己的抽象思维没被点拨透。
@racketresult{到研究生阶段，实际上就没啥文科理科之分了
 (但确实有很多歪瓜裂枣的专业在糊弄人)。
 学编程，可以让你真实的体会到什么是@bold{文理跨学科}。}
跑题了。

举例来说，创业第一步是按程序注册一个公司；上班请假要按一定程序审批。再近一点，每天起床按什么顺序早安洗脸刷牙吃早饭、选择什么样的出行方式去学校；临近开学欠下一屁股作业债，如何做到多支笔同时花式答题；等等等等。这些都是计算思维。
“编程”用英语说是Programming，而这个单词本来的意思有“规划”，猜猜看这是不是巧合？

其实，计算思维也是这个信息时代众多前沿科技中，唯一一个可以被普通人接触到的技术：
你只需要一台电脑，花个两三年时间入门编程即可，而不用专门的实验室。

@handbook-action{编程与@type{文科}和{艺体}}

@;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@handbook-reference[]
